"use strict";(self.webpackChunkreference_docs=self.webpackChunkreference_docs||[]).push([[6561],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=u(n),m=l,h=d["".concat(s,".").concat(m)]||d[m]||p[m]||r;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:l,i[1]=o;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},68112:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>u});var a=n(87462),l=(n(67294),n(3905));const r={id:"row-level-security",title:"Row Level Security",description:"Secure your data using Postgres Row Level Security."},i=void 0,o={unversionedId:"guides/auth/row-level-security",id:"guides/auth/row-level-security",title:"Row Level Security",description:"Secure your data using Postgres Row Level Security.",source:"@site/docs/guides/auth/row-level-security.mdx",sourceDirName:"guides/auth",slug:"/guides/auth/row-level-security",permalink:"/docs/guides/auth/row-level-security",draft:!1,editUrl:"https://github.com/docs/guides/auth/row-level-security.mdx",tags:[],version:"current",frontMatter:{id:"row-level-security",title:"Row Level Security",description:"Secure your data using Postgres Row Level Security."}},s={},u=[{value:"Policies",id:"policies",level:2},{value:"Helper Functions",id:"helper-functions",level:2},{value:"<code>auth.uid()</code>",id:"authuid",level:3},{value:"<code>auth.jwt()</code>",id:"authjwt",level:3},{value:"<code>auth.role()</code>",id:"authrole",level:3},{value:"<code>auth.email()</code>",id:"authemail",level:3},{value:"Examples",id:"examples",level:2},{value:"Allow read access",id:"allow-read-access",level:3},{value:"Restrict updates",id:"restrict-updates",level:3},{value:"Only anon or authenticated access",id:"only-anon-or-authenticated-access",level:3},{value:"Policies with joins",id:"policies-with-joins",level:3},{value:"Policies with security definer functions",id:"policies-with-security-definer-functions",level:3},{value:"Verifying email domains",id:"verifying-email-domains",level:3},{value:"Time to live for rows",id:"time-to-live-for-rows",level:3},{value:"Advanced policies",id:"advanced-policies",level:3},{value:"Tips",id:"tips",level:2},{value:"Enable Realtime for database tables",id:"enable-realtime-for-database-tables",level:3},{value:"You don&#39;t have to use policies",id:"you-dont-have-to-use-policies",level:3},{value:"Never use a service key on the client",id:"never-use-a-service-key-on-the-client",level:3}],c={toc:u};function d(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"When you need granular authorization rules, nothing beats PostgreSQL's ",(0,l.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/ddl-rowsecurity.html"},"Row Level Security (RLS)"),"."),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/sql-createpolicy.html"},"Policies")," are PostgreSQL's rule engine. They are incredibly powerful and flexible, allowing you to write complex SQL rules which fit your unique business needs."),(0,l.kt)("div",{class:"video-container"},(0,l.kt)("iframe",{src:"https://www.youtube-nocookie.com/embed/Ow_Uzedfohk",frameBorder:"1",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowFullScreen:!0})),(0,l.kt)("h2",{id:"policies"},"Policies"),(0,l.kt)("p",null,"Policies are easy to understand once you get the hang of them. Each policy is attached to a table, and the policy is executed\nevery time a table is accessed.\nYou can just think of them as adding a ",(0,l.kt)("inlineCode",{parentName:"p"},"WHERE")," clause to every query. For example a policy like this ..."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'create policy "Individuals can view their own todos."\n    on todos for select\n    using ( auth.uid() = user_id );\n')),(0,l.kt)("p",null,".. would translate to this whenever a user tries to select from the todos table:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"select *\nfrom todos\nwhere auth.uid() = todos.user_id; -- Policy is implicitly added.\n")),(0,l.kt)("h2",{id:"helper-functions"},"Helper Functions"),(0,l.kt)("p",null,"Supabase provides you with a few easy functions that you can use with your policies."),(0,l.kt)("h3",{id:"authuid"},(0,l.kt)("inlineCode",{parentName:"h3"},"auth.uid()")),(0,l.kt)("p",null,"Returns the ID of the user making the request."),(0,l.kt)("h3",{id:"authjwt"},(0,l.kt)("inlineCode",{parentName:"h3"},"auth.jwt()")),(0,l.kt)("p",null,"Returns the JWT of the user making the request."),(0,l.kt)("h3",{id:"authrole"},(0,l.kt)("inlineCode",{parentName:"h3"},"auth.role()")),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"Deprecated")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"auth.role()")," function has been deprecated in favour of using the ",(0,l.kt)("inlineCode",{parentName:"p"},"TO")," field, natively supported within Postgres."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"-- DEPRECATED\ncreate policy \"Public profiles are viewable by everyone.\"\non profiles for select using (\n  auth.role() = 'authenticated' or auth.role() = 'anon'\n);\n\n-- RECOMMENDED\ncreate policy \"Public profiles are viewable by everyone.\"\non profiles for select\nto authenticated, anon\nusing (\n  true\n);\n")),(0,l.kt)("h3",{id:"authemail"},(0,l.kt)("inlineCode",{parentName:"h3"},"auth.email()")),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"Deprecated. Use ",(0,l.kt)("inlineCode",{parentName:"p"},"auth.jwt() ->> 'email'")," instead.")),(0,l.kt)("p",null,"Returns the email of the user making the request."),(0,l.kt)("h2",{id:"examples"},"Examples"),(0,l.kt)("p",null,"Here are some examples to show you the power of PostgreSQL's RLS."),(0,l.kt)("h3",{id:"allow-read-access"},"Allow read access"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'-- 1. Create table\ncreate table profiles (\n  id uuid references auth.users,\n  avatar_url text\n);\n\n-- 2. Enable RLS\nalter table profiles\n  enable row level security;\n\n-- 3. Create Policy\ncreate policy "Public profiles are viewable by everyone."\n  on profiles for select using (\n    true\n  );\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Creates a table called ",(0,l.kt)("inlineCode",{parentName:"li"},"profiles")," in the public schema (default schema)."),(0,l.kt)("li",{parentName:"ol"},"Enables Row Level Security."),(0,l.kt)("li",{parentName:"ol"},"Creates a policy which allows all ",(0,l.kt)("inlineCode",{parentName:"li"},"select")," queries to run.")),(0,l.kt)("h3",{id:"restrict-updates"},"Restrict updates"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'-- 1. Create table\ncreate table profiles (\n  id uuid references auth.users,\n  avatar_url text\n);\n\n-- 2. Enable RLS\nalter table profiles\n  enable row level security;\n\n-- 3. Create Policy\ncreate policy "Users can update their own profiles."\n  on profiles for update using (\n    auth.uid() = id\n  );\n')),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Creates a table called ",(0,l.kt)("inlineCode",{parentName:"li"},"profiles")," in the public schema (default schema)."),(0,l.kt)("li",{parentName:"ol"},"Enables RLS."),(0,l.kt)("li",{parentName:"ol"},"Creates a policy which allows logged in users to update their own data.")),(0,l.kt)("h3",{id:"only-anon-or-authenticated-access"},"Only anon or authenticated access"),(0,l.kt)("p",null,"You can add a Postgres role"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'create policy "Public profiles are viewable by everyone."\non profiles for select\nto authenticated, anon\nusing (\n  true\n);\n')),(0,l.kt)("h3",{id:"policies-with-joins"},"Policies with joins"),(0,l.kt)("p",null,'Policies can even include table joins. This example shows how you can query "external" tables to build more advanced rules.'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'create table teams (\n  id serial primary key,\n  name text\n);\n\n-- 2. Create many to many join\ncreate table members (\n  team_id bigint references teams,\n  user_id uuid references auth.users\n);\n\n-- 3. Enable RLS\nalter table teams\n  enable row level security;\n\n-- 4. Create Policy\ncreate policy "Team members can update team details if they belong to the team."\n  on teams\n  for update using (\n    auth.uid() in (\n      select user_id from members\n      where team_id = id\n    )\n  );\n')),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Note:")," If RLS is also enabled for ",(0,l.kt)("em",{parentName:"p"},"members"),", the user must also have read (",(0,l.kt)("em",{parentName:"p"},"select"),") access to ",(0,l.kt)("em",{parentName:"p"},"members"),". Otherwise the joined query will not yield any results."),(0,l.kt)("h3",{id:"policies-with-security-definer-functions"},"Policies with security definer functions"),(0,l.kt)("p",null,"Policies can also make use of ",(0,l.kt)("inlineCode",{parentName:"p"},"security definer functions"),". This is useful in a many-to-many relationship where you want to restrict access to the linking table. Following the ",(0,l.kt)("inlineCode",{parentName:"p"},"teams")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"members")," example from above, this example shows how you can use the security definer function in combination with a policy to control access to the ",(0,l.kt)("inlineCode",{parentName:"p"},"members")," table."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"-- 1. Follow example for 'Policies with joins' above\n\n-- 2.  Enable RLS\nalter table members\n  enable row level security\n\n-- 3.  Create security definer function\ncreate or replace function get_teams_for_authenticated_user()\nreturns setof bigint\nlanguage sql\nsecurity definer\nset search_path = public\nstable\nas $$\n    select team_id\n    from members\n    where user_id = auth.uid()\n$$;\n\n-- 4. Create Policy\ncreate policy \"Team members can update team members if they belong to the team.\"\n  on members\n  for all using (\n    team_id in (\n      select get_teams_for_authenticated_user()\n    )\n  );\n\n")),(0,l.kt)("h3",{id:"verifying-email-domains"},"Verifying email domains"),(0,l.kt)("p",null,"Postgres has a function ",(0,l.kt)("inlineCode",{parentName:"p"},"right(string, n)")," that returns the rightmost n characters of a string.\nYou could use this to match staff member's email domains."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"-- 1. Create table\ncreate table leaderboard (\n  id uuid references auth.users,\n  high_score bigint\n);\n\n-- 2. Enable RLS\nalter table leaderboard\n  enable row level security;\n\n-- 3. Create Policy\ncreate policy \"Only Blizzard staff can update leaderboard\"\n  on leaderboard\n  for update using (\n    right(auth.jwt() ->> 'email', 13) = '@blizzard.com'\n  );\n")),(0,l.kt)("h3",{id:"time-to-live-for-rows"},"Time to live for rows"),(0,l.kt)("p",null,"Policies can also be used to implement TTL or time to live feature that you see in Instagram stories or Snapchat.\nIn the following example, rows of ",(0,l.kt)("inlineCode",{parentName:"p"},"stories")," table are available only if they have been created within the last 24 hours."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"-- 1. Create table\ncreate table if not exists stories (\n  id uuid not null primary key DEFAULT uuid_generate_v4(),\n  created_at timestamp with time zone default timezone('utc' :: text, now()) not null,\n  content text not null\n);\n\n-- 2. Enable RLS\nalter table stories\n  enable row level security;\n\n-- 3. Create Policy\ncreate policy \"Stories are live for a day\"\n  on stories\n  for select using (\n    created_at > (current_timestamp - interval '1 day')\n  );\n")),(0,l.kt)("h3",{id:"advanced-policies"},"Advanced policies"),(0,l.kt)("p",null,"Use the full power of SQL to build extremely advanced rules."),(0,l.kt)("p",null,"In this example, we will create a ",(0,l.kt)("inlineCode",{parentName:"p"},"posts")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"comments")," tables and then create a policy that depends on another policy.\n(In this case, the comments policy depends on the posts policy.)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},'create table posts (\n  id            serial    primary key,\n  creator_id    uuid      not null     references auth.users(id),\n  title         text      not null,\n  body          text      not null,\n  publish_date  date      not null     default now(),\n  audience      uuid[]    null -- many to many table omitted for brevity\n);\n\ncreate table comments (\n  id            serial    primary key,\n  post_id       int       not null     references posts(id)  on delete cascade,\n  user_id       uuid      not null     references auth.users(id),\n  body          text      not null,\n  comment_date  date      not null     default now()\n);\n\ncreate policy "Creator can see their own posts"\non posts\nfor select\nusing (\n  auth.uid() = posts.creator_id\n);\n\ncreate policy "Logged in users can see the posts if they belong to the post \'audience\'."\non posts\nfor select\nusing (\n  auth.uid() = any (posts.audience)\n);\n\ncreate policy "Users can see all comments for posts they have access to."\non comments\nfor select\nusing (\n  exists (\n    select 1 from posts\n    where posts.id = comments.post_id\n  )\n);\n')),(0,l.kt)("h2",{id:"tips"},"Tips"),(0,l.kt)("h3",{id:"enable-realtime-for-database-tables"},"Enable Realtime for database tables"),(0,l.kt)("p",null,"Realtime server broadcasts database changes to authorized users depending on your Row Level Security (RLS) policies.\nWe recommend that you enable row level security and set row security policies on tables that you add to the publication.\nHowever, you may choose to disable RLS on a table and have changes broadcast to all connected clients."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"/**\n * REALTIME SUBSCRIPTIONS\n * Realtime enables listening to any table in your public schema.\n */\n\nbegin;\n  -- remove the realtime publication\n  drop publication if exists supabase_realtime;\n\n  -- re-create the publication but don't enable it for any tables\n  create publication supabase_realtime;\ncommit;\n\n-- add a table to the publication\nalter publication supabase_realtime add table products;\n\n-- add other tables to the publication\nalter publication supabase_realtime add table posts;\n")),(0,l.kt)("h3",{id:"you-dont-have-to-use-policies"},"You don't have to use policies"),(0,l.kt)("p",null,"You can also put your authorization rules in your middleware, similar to how you would create security rules with any other ",(0,l.kt)("inlineCode",{parentName:"p"},"backend <-> middleware <-> frontend")," architecture."),(0,l.kt)("p",null,'Policies are a tool. In the case of "serverless/Jamstack" setups, they are especially effective because you don\'t have to deploy any middleware at all.'),(0,l.kt)("p",null,'However, if you want to use another authorization method for your applications, that\'s also fine. Supabase is "just Postgres", so if your application\nworks with Postgres, then it also works with Supabase.'),(0,l.kt)("p",null,'Tip: Make sure to enable RLS for all your tables, so that your tables are inaccessible. Then use the "Service" which we provide, which is designed to bypass RLS.'),(0,l.kt)("h3",{id:"never-use-a-service-key-on-the-client"},"Never use a service key on the client"),(0,l.kt)("p",null,'Supabase provides special "Service" keys, which can be used to bypass all RLS.\nThese should never be used in the browser or exposed to customers, but they are useful for administrative tasks.'))}d.isMDXComponent=!0}}]);